# -*- coding: utf-8 -*-
"""Sistem-Rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hVGfGfkug1s0yA7kfAIYfH2O0bo5uB7B

# **Sistem Rekomendasi - Aryo Daffa Khairuddin**

### Link Dataset : [Fashion Product](https://www.kaggle.com/datasets/bhanupratapbiswas/fashion-products/data)

### Link Full Project : https://github.com/aryo04/Sistem-Rekomendasi

# **Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity, euclidean_distances
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.preprocessing import OneHotEncoder

"""**Insigh**t :
* `pandas`: Untuk mengolah dan menganalisis data dalam format tabel.
* `numpy`: Untuk operasi angka dan array.
* `matplotlib.pyplot` dan `seaborn`: Untuk membuat grafik dan visualisasi data
* `sklearn.metrics.pairwise - cosine_similarity`, `euclidean_distances` : Untuk menghitung kemiripan antar vektor fitur.
* `sklearn.preprocessing - OneHotEncoder`: Untuk mengubah data kategorikal menjadi format numerik biner yang dapat diproses model machine learning.

# **Load Data**
"""

df = pd.read_csv('fashion_products.csv')
df.head()

"""**Insight** :  Memuat file CSV "fashion_products.csv" dan melihat isi awal dataset dengan menampilkan 5 baris pertama.

# **Data Understanding**
"""

print("Jumlah baris:", df.shape[0])
print("Jumlah kolom:", df.shape[1])

"""**Insight** : df.shape() digunakan untuk mengetahui jumlah baris dan kolom dimana dari dataset tersebut mempunyai 1000 baris dan 9 kolom."""

df.info()

"""**Insight** : df.info() digunakan untuk menampilkan struktur dataset, termasuk jumlah baris baris, nama kolom, jumlah non-null, serta tipe data dari masing-masing kolom."""

df.describe()

"""**Insight** :

* `User ID` dan `Product ID` menunjukkan interaksi dari 100 user terhadap 1000 produk dengan distribusi yang cukup merata.
* `Price` harga produk dimulai dari 10-100.
* `Rating` rating  dimulai dari 1 sampai hampir 5 dengan rata-rata hampir 3.
"""

rating_counts = df['Rating'].value_counts()
print(rating_counts)
print(f"\nTotal rating dengan 0: {rating_counts.get(0, 0)}")

"""**Insight** :

Tidak terdapat rating dengan nilai 0.
"""

df.isnull().sum()

"""**Insight** :

Tidak terdapat missing value.
"""

df.duplicated().sum()

"""Tidak terdapat data yang duplikat.

## **Eksploratory Data Analyst**

### Distribusi Variabel Kategorikal
"""

plt.figure(figsize=(15, 15))

# Plot distribusi Kategori
plt.subplot(3, 2, 1)
sns.countplot(data=df, x='Category', palette='viridis')
plt.title('Distribusi Kategori Produk')
plt.xticks(rotation=45)

# Plot distribusi Merek
plt.subplot(3, 2, 2)
sns.countplot(data=df, x='Brand', palette='viridis')
plt.title('Distribusi Merek')
plt.xticks(rotation=45)

# Plot distribusi Warna
plt.subplot(3, 2, 3)
sns.countplot(data=df, x='Color', palette='viridis')
plt.title('Distribusi Warna')
plt.xticks(rotation=45)

# Plot distribusi Ukuran
plt.subplot(3, 2, 4)
sns.countplot(data=df, x='Size', palette='viridis')
plt.title('Distribusi Ukuran')
plt.xticks(rotation=45)

# Plot distribusi Ukuran
plt.subplot(3, 2, 5)
sns.countplot(data=df, x='Product Name', palette='viridis')
plt.title('Distribusi Nama Produk')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

"""**Insight** :

1. `Category` : Tiga kategori fashion (Men’s, Women’s, Kid’s) memiliki distribusi yang cukup seimbang, namun Kid’s Fashion sedikit lebih tinggi.

2. `Brand` : Semua brand populer (Adidas, H&M, Zara, Gucci, Nike) memiliki jumlah produk yang hampir merata, dengan Nike sedikit lebih tinggi.

3. `Color` : Warna White paling sering muncul, diikuti oleh Yellow dan Blue. Warna Red paling sedikit.

4. `Size` : Distribusi merata dengan XL dan L sedikit lebih tinggi dibandingkan s dan m.

5. `Product Name` : Produk Jeans dan Shoes paling tinggi, sementara Sweater memiliki jumlah paling sedikit.

### Distribusi Rating per Kategori
"""

plt.figure(figsize=(10, 6))
sns.boxplot(x='Category', y='Rating', data=df)
plt.title('Distribusi Rating per Kategori')
plt.xlabel('Kategori')
plt.ylabel('Rating')
plt.xticks(rotation=45)
plt.show()

"""**Insight** :

* Ketiga kategori (`Men's Fashion, Women's Fashion, dan Kids Fashion`) menunjukkan distribusi rating yang serupa, dengan rentang rating dari 1 hingga 5.

* Median rating dari ketiga kategori berada di sekitar 3, dengan:

  * `Women's Fashion` dan `Kid's Fashion` memiliki median sedikit lebih tinggi dari `Men's Fashion`.

  * Ini mengindikasikan bahwa produk di dua kategori tersebut cenderung mendapat penilaian lebih tinggi secara konsisten dibanding `Men's Fashion`.

* IQR terlihat cukup lebar di semua kategori, menunjukkan keragaman penilaian pengguna cukup besar.

### Rata-rata Rating per Kategori
"""

avg_rating_by_category = df.groupby('Category')['Rating'].mean().sort_values()
plt.figure(figsize=(6, 4))
sns.barplot(x=avg_rating_by_category.index, y=avg_rating_by_category.values, palette='Blues')
plt.title('Rata-rata Rating per Kategori')
plt.xlabel('Kategori')
plt.ylabel('Rata-rata Rating')
plt.show()

"""**Insight** :

1. `Kids' Fashion` memiliki rata-rata rating tertinggi

  Nilai rata-rata rating kategori ini sedikit di atas 3.0, menunjukkan bahwa secara umum, produk-produk Kids' Fashion lebih disukai oleh pelanggan dibanding dua kategori lainnya.

2. `Women's Fashion` berada di urutan kedua

  Rata-rata rating-nya tepat di angka 3.0, menandakan kepuasan pelanggan yang cukup baik dan stabil.

3. `Men's Fashion` memiliki rata-rata rating terendah

  Dengan rata-rata rating sedikit di bawah 3.0, Men's Fashion tampaknya memiliki performa penilaian pengguna yang sedikit lebih rendah dibandingkan dua kategori lainnya.

### Distribusi Variabel Numerik
"""

plt.figure(figsize=(12, 5))

# Plot distribusi Harga
plt.subplot(1, 2, 1)
sns.histplot(data=df, x='Price', kde=True, bins=20)
plt.title('Distribusi Harga')

# Plot distribusi Rating
plt.subplot(1, 2, 2)
sns.histplot(data=df, x='Rating', kde=True, bins=10)
plt.title('Distribusi Rating')

plt.tight_layout()
plt.show()

"""**Insight** :

* Harga produk tersebar merata di rentang 10 hingga 100 dan distribusi harga cenderung datar, menunjukkan ketersediaan produk di berbagai level harga secara seimbang.

* Rating tersebar dari 1 hingga 5, dengan puncak pada rating 3 dan Rrating 1 dan 5 juga cukup tinggi, menunjukkan pengalaman pengguna yang beragam—baik sangat puas maupun sangat tidak puas.

# **Data Preparation**

### Seleksi Fitur
"""

# Memilih fitur untuk rekomendasi
features = ['Product Name', 'Brand', 'Category', 'Color', 'Size']
data_features = df[features]

"""**Insight** : Seleksi fitur dilakukan untuk menentukan atribut yang paling relevan dalam menghasilkan rekomendasi yang bermakna. Fitur Product Name, Brand, Category, Color, dan Size dipilih karena mewakili karakteristik utama produk fashion yang memengaruhi preferensi pengguna

### Encoding
"""

# One-Hot Encoding
encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')
encoded_features = encoder.fit_transform(data_features)
encoded_df = pd.DataFrame(encoded_features, columns=encoder.get_feature_names_out(features))

"""**Insight** : Fitur seperti Product Name, Brand, Category, Color, dan Size bersifat kategorikal, sedangkan cosine similarity memerlukan data dalam format numerik. One-Hot Encoding mengubah setiap kategori menjadi vektor biner, memungkinkan perhitungan kesamaan matematis antar produk dan sistem dapat mengukur jarak atau kesamaan antar produk berdasarkan atribut ini.

### Penggabungan Data
"""

# Menambahkan kolom asli untuk referensi
encoded_df = pd.concat([encoded_df, df[['Product ID', 'Product Name', 'Brand', 'Category', 'Color', 'Size', 'Rating', 'Price']]], axis=1)

"""**Insight** : Setelah encoding, DataFrame hanya berisi vektor biner yang sulit diinterpretasikan tanpa konteks asli. Menambahkan kolom referensi seperti Product ID, Product Name, Brand, Category, Color, Size, Rating, dan Price memungkinkan pengguna untuk memahami produk yang direkomendasikan dengan jelas.

# **Modeling**

### Consine Similartiy
"""

cosine_sim = cosine_similarity(encoded_df[encoder.get_feature_names_out(features)])
cosine_sim

"""**Insight** : menghitung cosine similarity antara semua produk dalam dataset berdasarkan fitur yang telah dienkode."""

# Fungsi untuk mendapatkan rekomendasi berdasarkan atribut degnan consine similarity
def get_recommendations_by_attributes(product_name, brand, category, color, size, top_n=5):
    input_data = pd.DataFrame({
        'Product Name': [product_name],
        'Brand': [brand],
        'Category': [category],
        'Color': [color],
        'Size': [size]
    })
    input_encoded = encoder.transform(input_data)
    sim_scores = cosine_similarity(input_encoded, encoded_df[encoder.get_feature_names_out(features)])
    sim_scores = list(enumerate(sim_scores[0]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[:top_n]
    product_indices = [i[0] for i in sim_scores]
    similarity_scores = [i[1] for i in sim_scores]
    recommendations = df.iloc[product_indices][['Product ID', 'Product Name', 'Brand', 'Category', 'Color', 'Size', 'Rating', 'Price']].copy()
    recommendations['Similarity Score'] = similarity_scores
    return recommendations, product_indices, similarity_scores

# --- Test Case ---
product_name = 'Shoes'
brand = 'Zara'
category = "Men's Fashion"
color = 'White'
size = 'S'

# --- Menghasilkan dan Menampilkan Rekomendasi ---
print("\nRekomendasi (Cosine Similarity):")
recommendations, _, _ = get_recommendations_by_attributes(
    product_name, brand, category, color, size, top_n=5
)
print(recommendations)

"""**Insight** : fungsi di atas adalah komponen operasional dari model, yang menerima input atribut pengguna (Product Name, Brand, Category, Color, Size) dan mengembalikan top-5 rekomendasi produk berdasarkan kesamaan dengan input.

### Euclidean Distance
"""

# Menghitung Matriks Jarak Euclidean
euclidean_dist = euclidean_distances(encoded_df[encoder.get_feature_names_out(features)])
euclidean_sim = 1 / (1 + euclidean_dist)
euclidean_sim

"""**Insight** : Menghitung matriks jarak euclidean antara semua pasangan produk berdasarkan fitur yang telah dienkode."""

# Fungsi untuk mendapatkan rekomendasi berdasarkan atribut dengan ecludian distances
def get_recommendations_by_attributes_euclidean(product_name, brand, category, color, size, top_n=5):
    input_data = pd.DataFrame({
        'Product Name': [product_name],
        'Brand': [brand],
        'Category': [category],
        'Color': [color],
        'Size': [size]
    })
    input_encoded = encoder.transform(input_data)
    dist_scores = euclidean_distances(input_encoded, encoded_df[encoder.get_feature_names_out(features)])
    sim_scores = 1 / (1 + dist_scores[0])
    sim_scores = list(enumerate(sim_scores))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[:top_n]

    product_indices = [i[0] for i in sim_scores]
    similarity_scores = [i[1] for i in sim_scores]
    recommendations = df.iloc[product_indices][['Product ID', 'Product Name', 'Brand', 'Category', 'Color', 'Size', 'Rating', 'Price']].copy()
    recommendations['Similarity Score'] = similarity_scores
    return recommendations, product_indices, similarity_scores

# Test case
product_name = 'Shoes'
brand = 'Zara'
category = "Men's Fashion"
color = 'White'
size = 'S'

# Menampilkan Rekomendasi
print("\nRekomendasi (Euclidean Distance):")
recommendations, _, _ = get_recommendations_by_attributes_euclidean(
    product_name, brand, category, color, size, top_n=5
)
print(recommendations)

"""**Insight** : Fungsi menerima input atribut, kemudian menghitung jarak Euclidean antara input dan semua produk, mengonversi ke skor kesamaan, lalu memilih top-5 produk dengan kesamaan tertinggi.

# **Evaluation**

### Cosine Similarity
"""

# Fungsi untuk menghitung Precision@5 dan Recall@5
def evaluate_recommendations(product_name, brand, category, color, size, top_n=5, similarity_threshold=0.9):
    recommendations, product_indices, similarity_scores = get_recommendations_by_attributes(
        product_name, brand, category, color, size, top_n
    )
    relevant_items = []
    input_data = pd.DataFrame({
        'Product Name': [product_name],
        'Brand': [brand],
        'Category': [category],
        'Color': [color],
        'Size': [size]
    })
    input_encoded = encoder.transform(input_data)
    sim_scores_all = cosine_similarity(input_encoded, encoded_df[encoder.get_feature_names_out(features)])[0]
    relevant_items = [i for i, score in enumerate(sim_scores_all) if score >= similarity_threshold]

    relevant_recommendations = sum(1 for idx in product_indices if idx in relevant_items)
    precision = relevant_recommendations / top_n if top_n > 0 else 0
    total_relevant = len(relevant_items)
    recall = relevant_recommendations / total_relevant if total_relevant > 0 else 0

    return recommendations, precision, recall, total_relevant

# Test case
product_name = 'Shoes'
brand = 'Zara'
category = "Men's Fashion"
color = 'White'
size = 'S'

# Evaluasi
recommendations, precision, recall, total_relevant = evaluate_recommendations(
    product_name, brand, category, color, size, top_n=5, similarity_threshold=0.8
)

# Menampilkan rekomendasi dan hasil evaluasi
print("\nRekomendasi Cosine Similarty:")
print(recommendations)
print(f"\nPrecision@5: {precision:.2f}")
print(f"Recall@5: {recall:.2f}")
print(f"Total Item Relevan: {total_relevant}")

"""**Insight** : Hasil evaluasi menunjukkan bahwa sistem rekomendasi berbasis cosine similarity memiliki Precision@5 sebesar 0.80 dan Recall@5 sebesar 1.00. Artinya, dari 5 item yang direkomendasikan, 4 di antaranya relevan dengan preferensi pengguna, dan seluruh item relevan berhasil ditemukan. Hal ini menunjukkan bahwa sistem cukup akurat dan sangat efektif dalam menemukan produk yang sesuai dengan kebutuhan pengguna.

### Euclidean Distance
"""

# Fungsi untuk Menghitung Precision@5 dan Recall@5
def evaluate_recommendations_euclidean(product_name, brand, category, color, size, top_n=5, similarity_threshold=0.9):
    recommendations, product_indices, similarity_scores = get_recommendations_by_attributes_euclidean(
        product_name, brand, category, color, size, top_n
    )
    relevant_items = []
    input_data = pd.DataFrame({
        'Product Name': [product_name],
        'Brand': [brand],
        'Category': [category],
        'Color': [color],
        'Size': [size]
    })
    input_encoded = encoder.transform(input_data)
    dist_scores = euclidean_distances(input_encoded, encoded_df[encoder.get_feature_names_out(features)])[0]
    sim_scores_all = 1 / (1 + dist_scores)
    relevant_items = [i for i, score in enumerate(sim_scores_all) if score >= similarity_threshold]

    relevant_recommendations = sum(1 for idx in product_indices if idx in relevant_items)
    precision = relevant_recommendations / top_n if top_n > 0 else 0
    total_relevant = len(relevant_items)
    recall = relevant_recommendations / total_relevant if total_relevant > 0 else 0

    return recommendations, precision, recall, total_relevant

# Test case
product_name = 'Shoes'
brand = 'Zara'
category = "Men's Fashion"
color = 'White'
size = 'S'

# Evaluasi
recommendations, precision, recall, total_relevant = evaluate_recommendations_euclidean(
    product_name, brand, category, color, size, top_n=5, similarity_threshold=0.8
)

# Menampilkan Hanya Rekomendasi dan Hasil Evaluasi
print("\nRekomendasi Ecludean Distance:")
print(recommendations)
print(f"\nPrecision@5: {precision:.2f}")
print(f"Recall@5: {recall:.2f}")
print(f"Total Item Relevan: {total_relevant}")

"""**Insight** : Hasil evaluasi menunjukkan bahwa sistem rekomendasi berbasis Euclidean distance memiliki Precision@5 sebesar 0.80 dan Recall@5 sebesar 1.00. Artinya, dari 5 item yang direkomendasikan, 4 item relevan dengan preferensi pengguna (80%), dan semua item relevan yang tersedia berhasil direkomendasikan (100% recall). Dengan demikian, sistem sangat efektif dalam menemukan item yang sesuai kebutuhan pengguna dan memberikan rekomendasi yang cukup akurat."""